---@diagnostic disable: lowercase-global

rtk.version("local:crates/rtk-rustc-driver")

rtk.emit([[
// Autogenerated by RTK

]])

local remembered_ts_types_by_location = {}

-- extracts the route params from a route string by peeking inside of curlies
function route_param_names(route_str)
	local params = {}
	for param in route_str:gmatch("{(.-)}") do
		table.insert(params, param)
	end
	return params
end

--- attempts to extract the inner type of an axum tuple extractor, returning nil if the given type is not
--- a match
---@param type TypeValue
---@return TypeValue|nil
function try_axum_tuple_extractor(type, extractor_name)
	if type.variant_name == "RecursiveRef" then
		local original = remembered_ts_types_by_location[type.variant_data.path]
		if not original then
			rtk.note(
				"Could not find original type for recursive reference: "
					.. type.variant_data.path[#type.variant_data.path]
			)
			return nil
		end
		return try_axum_tuple_extractor(original, extractor_name)
	end

	if type.variant_name ~= "Struct" then
		rtk.note("Got variant type " .. type.variant_name .. " when expecting Struct for tuple extractor")
		return nil
	end

	if
		type.variant_data.location.crate_name ~= "axum"
		or type.variant_data.location.path[#type.variant_data.location.path] ~= extractor_name
	then
		rtk.note(
			"Got struct "
				.. type.variant_data.location.path[#type.variant_data.location.path]
				.. " when expecting "
				.. extractor_name
		)
		return nil
	end

	assert(#type.variant_data.fields == 1, "Tuple extractor must have exactly one (anonymous) field")

	return type.variant_data.fields[1].value
end

---converts a rust type into an equivalent typescript type. this is a rough implementation for this example,
---but this could be much more robust in a real app
---@param rt TypeValue
---@return string
function rust_type_into_typescript_type(rt)
	if
		rt.variant_name == "U8"
		or rt.variant_name == "U16"
		or rt.variant_name == "U32"
		or rt.variant_name == "U64"
		or rt.variant_name == "U128"
		or rt.variant_name == "Usize"
	then
		return "number"
	end

	if
		rt.variant_name == "I8"
		or rt.variant_name == "I16"
		or rt.variant_name == "I32"
		or rt.variant_name == "I64"
		or rt.variant_name == "I128"
		or rt.variant_name == "Isize"
	then
		return "number"
	end

	if rt.variant_name == "F32" or rt.variant_name == "F64" then
		return "number"
	end

	if rt.variant_name == "Boolean" then
		return "boolean"
	end

	if rt.variant_name == "Vec" then
		local inner_type = rust_type_into_typescript_type(rt.variant_data)
		return inner_type .. "[]"
	end

	if rt.variant_name == "Tuple" then
		local inner_types = {}
		for _, inner_type in ipairs(rt.variant_data) do
			table.insert(inner_types, rust_type_into_typescript_type(inner_type))
		end
		return "[" .. table.concat(inner_types, ", ") .. "]"
	end

	if rt.variant_name == "Struct" then
		local struct_str = ""
		for _, field in ipairs(rt.variant_data.fields) do
			local field_type = rust_type_into_typescript_type(field.value)
			struct_str = struct_str .. field.name .. ": " .. field_type .. ", "
		end

		remembered_ts_types_by_location[rt.variant_data.location.path] = rt

		return "{ " .. struct_str:sub(1, -3) .. " }" -- remove trailing comma and space
	end

	if rt.variant_name == "String" then
		return "string"
	end

	if rt.variant_name == "RecursiveRef" then
		local original = remembered_ts_types_by_location[rt.variant_data.path]
		return rust_type_into_typescript_type(original)
	end

	return "any"
end

local routes = rtk.query_method_calls({
	location = {
		crate_name = "axum",
		path = { "routing", "route" },
		impl_block_number = 3,
	},
})

-- this is each call to `.route("/route-here", method_here(route_fn_here))`
for _, route in ipairs(routes) do
	local route_path_arg = route.args[1]
	assert(route_path_arg.variant_name == "StringLiteral", "First argument to route must be a string literal")

	local route_method_call = route.args[2]
	assert(
		route_method_call.variant_name == "FunctionCall",
		"Second argument to route must be a route method function call"
	)

	-- the method itself will be the last value in the path to the function call, i.e. the route itself
	-- the full method path will be for instance axum::routing::method_routing::get, so we only want the tail
	local method = route_method_call.variant_data.location.path[#route_method_call.variant_data.location.path]

	-- the first (and only) argument to the route method function is the route fn, so lets grab that
	local route_fn = route_method_call.variant_data.args[1]
	-- this time, we're expecting a typed value itself to be passed in and not another function call, so lets pull
	-- out the route fn
	assert(route_fn.variant_name == "Type", "First argument to route method must be a type")
	assert(route_fn.variant_data.variant_name == "Function", "First argument to route method must be a function")

	local route_fn_args = route_fn.variant_data.variant_data.args_struct
	local route_fn_ret_type = route_fn.variant_data.variant_data.return_type

	local route_fn_name =
		route_fn.variant_data.variant_data.location.path[#route_fn.variant_data.variant_data.location.path]

	local param_names = route_param_names(route_path_arg.variant_data)

	local ts_fn_args_str = ""
	for _, arg in ipairs(route_fn_args.fields) do
		local maybe_extracts_path = try_axum_tuple_extractor(arg.value, "Path")
		if maybe_extracts_path then
			-- this is a path extractor, so we can use the param names from the route string
			local param_name = table.remove(param_names, 1)
			ts_fn_args_str = ts_fn_args_str
				.. string.format("%s: %s, ", param_name, rust_type_into_typescript_type(maybe_extracts_path))
		end

		local maybe_extracts_json = try_axum_tuple_extractor(arg.value, "Json")
		if maybe_extracts_json then
			-- this is a json extractor, so we can use the type of the json value
			ts_fn_args_str = ts_fn_args_str
				.. string.format("json: %s, ", rust_type_into_typescript_type(maybe_extracts_json))
		end

		local ts_fn_returns_str = "void"
		if route_fn_ret_type then
			rtk.note("Route function returns type: " .. route_fn_ret_type.variant_name)
			local maybe_returns_json = try_axum_tuple_extractor(route_fn_ret_type, "Json")
			if maybe_returns_json then
				ts_fn_returns_str = rust_type_into_typescript_type(maybe_returns_json)
			end
		end

		rtk.emit(string.format(
			[[

export async function %s(%s): Promise<%s> {
	return fetch("%s", {
		method: "%s",
		headers: json ? {
			"Content-Type": "application/json",
		} : {},
		body: json && JSON.stringify(json),
	});
}
]],
			route_fn_name,
			ts_fn_args_str,
			ts_fn_returns_str,
			route_path_arg.variant_data,
			method:upper()
		))
	end
end
