-- We dogfood RTK by using RTK itself to generate types for the Lua API exposed for userscripting.
-- Here you will find the Lua implementation, which you may decide to use yourself for your own apps however
-- its probably better to treat this as a template since its pretty specialized for the compiler!

rtk.version("local:crates/rtk-rustc-driver")

rtk.emit([[
--- Autogenerated by RTK

---@meta

---@class rtk
rtk = {}

]])

local pending_top_level_types = {}

-- defer function defs so they come after all of the top level types
local deferred_function_defs_str = ""

local function strsplit(inputstr, sep)
  if sep == nil then
    sep = "%s"
  end
  local t = {}
  for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
    table.insert(t, str)
  end
  return t
end

local function rust_type_value_into_lua_docstring_type(rt)
	if rt.variant_name == "String" then
		return "string"
	end

	if
		rt.variant_name == "U8"
		or rt.variant_name == "U16"
		or rt.variant_name == "U32"
		or rt.variant_name == "U64"
		or rt.variant_name == "U128"
		or rt.variant_name == "Usize"
	then
		return "number"
	end

	if
		rt.variant_name == "I8"
		or rt.variant_name == "I16"
		or rt.variant_name == "I32"
		or rt.variant_name == "I64"
		or rt.variant_name == "I128"
		or rt.variant_name == "Isize"
	then
		return "number"
	end

	if rt.variant_name == "F32" or rt.variant_name == "F64" then
		return "number"
	end

	if rt.variant_name == "Bool" then
		return "boolean"
	end

	if rt.variant_name == "Struct" then
		if rt.variant_data.location.crate_name == "mlua" then
			return ""
		end

		local struct_name = rt.variant_data.location.path[#rt.variant_data.location.path]
		pending_top_level_types[struct_name] = rt.variant_data

		return struct_name
	end

	if rt.variant_name == "Option" then
		return rust_type_value_into_lua_docstring_type(rt.variant_data) .. "|nil"
	end

	if rt.variant_name == "RecursiveRef" then
		local type_name = rt.variant_data.path[#rt.variant_data.path]
		return type_name
	end

	if rt.variant_name == "Vec" then
		local inner_type = rust_type_value_into_lua_docstring_type(rt.variant_data)
		return inner_type .. "[]"
	end

	if rt.variant_name == "Tuple" then
		local inner_types = {}
		for _, inner_type in ipairs(rt.variant_data) do
			table.insert(inner_types, rust_type_value_into_lua_docstring_type(inner_type))
		end
		return "{" .. table.concat(inner_types, ", ") .. "}"
	end

	if rt.variant_name == "Enum" then
		if rt.variant_data.location.crate_name == "mlua" then
			return ""
		end

		local enum_name = rt.variant_data.location.path[#rt.variant_data.location.path]
		pending_top_level_types[enum_name] = rt.variant_data

		return enum_name
	end

	return "any"
end

local api_fns = rtk.query_method_calls({
	location = {
		crate_name = "rtk_lua",
		path = { "ext", "TableSetFnExt", "set_rtk_api_fn" },
	},
})

for _, fn in ipairs(api_fns) do
	-- first one is the second index since the first index is the lua object passed in which we don't care about
	assert(fn.args[2].variant_name == "StringLiteral", "second argument to set_fn must be the global fn name")
	local rtk_global_val_name = fn.args[2].variant_data

	assert(fn.args[3].variant_name == "Type", "second argument to set_fn must be a type")
	local rtk_global_val_type = fn.args[3].variant_data

	assert(rtk_global_val_type.variant_name == "Closure", "third argument to set_fn must be a closure")
	local closure = rtk_global_val_type.variant_data

	assert(
		closure ~= nil,
		"closure must not be nil"
	)
	assert(
		closure.args ~= nil,
		"closure must have args"
	)

	local args_str = ""
	for i, arg in ipairs(closure.args) do
		deferred_function_defs_str = deferred_function_defs_str
			.. string.format(
				[[
---@param arg_%d %s
]],
				i,
				rust_type_value_into_lua_docstring_type(arg)
			)

		args_str = args_str .. "arg_" .. i
		if i < #closure.args then
			args_str = args_str .. ", "
		end
	end

	if closure.return_type ~= nil then
		local return_type_str = rust_type_value_into_lua_docstring_type(closure.return_type)
		if return_type_str == "" then
			return_type_str = "nil"
		end

		deferred_function_defs_str = deferred_function_defs_str
			.. string.format(
				[[
---@return %s
]],
				return_type_str
			)
	end

	deferred_function_defs_str = deferred_function_defs_str
		.. string.format(
			[[
function rtk.%s(%s) end

]],
			rtk_global_val_name,
			args_str
		)
end

local already_emitted = {}

local function has_pending_top_level_types()
	for k, _ in pairs(pending_top_level_types) do
		if already_emitted[k] == nil then
			return true
		end
	end
	return false
end

while has_pending_top_level_types() do
	for type_name, type_data in pairs(pending_top_level_types) do
		if already_emitted[type_name] then
			goto continue
		end

		if type_data.variants ~= nil then
			local variant_names = {}
			for _, variant in ipairs(type_data.variants) do
				local variant_fq_name = type_name .. variant.name

				if variant.attributes ~= nil then
					for _, attr in ipairs(variant.attributes) do
						if attr.name == "rtk_meta" then
							local kv_split = strsplit(attr.value_str, "=")
							local attr_name = kv_split[1]
							if attr_name == "override" then
								local override_type = kv_split[2]
								rtk.emit(string.format(
									[[
---@alias %s %s

]], variant_fq_name, override_type
								))
								variant_names[#variant_names + 1] = variant_fq_name
								goto variant_continue
							end
						end
					end
				end

				local variant_data_ty_strs = {}
				for i, field in pairs(variant.value.variant_data.fields) do
					if i > 1 then
						rtk.warn("currently cannot do multi-tuple enums")
						break
					end
					variant_data_ty_strs[#variant_data_ty_strs + 1] = rust_type_value_into_lua_docstring_type(field.value)
				end

				local variant_data_tys_str = table.concat(variant_data_ty_strs, ",")
				if variant_data_tys_str == "" then
					variant_data_tys_str = "nil"
				end

				rtk.emit(string.format(
				[[
---@class %s
---@field variant_name "%s"
---@field variant_data %s 
local %s = {}

]], variant_fq_name, variant.name, variant_data_tys_str, variant_fq_name))

				variant_names[#variant_names + 1] = variant_fq_name
				::variant_continue::
			end

			rtk.emit(string.format(
				[[

---@alias %s %s

]],
				type_name,
				table.concat(
					variant_names,
					"|"
				)
			))
		end

		if type_data.fields ~= nil then
			for i, field in ipairs(type_data.fields) do
				-- this is a newtype / alias delegate
				if i == 0 then
					rtk.emit(string.format(
						[[
---@alias %s %s

]], type_name, rust_type_value_into_lua_docstring_type(field.value)
					))
					goto continue
				end
			end
		rtk.emit(string.format(
			[[
---@class %s
]],
			type_name
		))
			for _, field in ipairs(type_data.fields) do
				rtk.emit(string.format(
					[[
---@field %s %s
]],
					field.name,
					rust_type_value_into_lua_docstring_type(field.value)
				))
			end

		rtk.emit(string.format(
			[[
local %s = {}

]],
			type_name
		))
		end


		already_emitted[type_name] = true

		::continue::
	end
end

rtk.emit(deferred_function_defs_str)
